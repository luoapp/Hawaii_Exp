C CONVOL3 PROGRAM                                       30 MAR 91
C
C MARK B MOFFETT, CODE 3111, NUSC, NEW LONDON, CT 06320
C
C      THIS PROGRAM COMPUTES NEARFIELD PARAMETRIC SOURCE LEVELS,
C BEAMWIDTHS, AND BEAM PATTERNS BY PERFORMING THE VOLUME INTEGRA-
C TION DESCRIBED IN J. ACOUST. SOC. AM., VOL. 63, 1622-1624 (1978)
C AND VOL. 69, PP. 404-409 (1981).
C  INPUTS:
C    RUNTYP  = S: SOURCE LEVEL ONLY
C            = W: SOURCE LEVEL AND BEAMWIDTH(S)
C            = P: SOURCE LEVEL, BEAMWIDTH(S), AND BEAM PATTERN(S)
C    SHAPE   = C: CIRCULAR PROJECTOR
C            = S: SQUARE PROJECTOR
C            = R: RECTANGULAR PROJECTOR
C            = E: ENDFIRE LINE
C            = A: ARBITRARY AXISYMMETRIC BEAM
C    DIAM    CIRCULAR PROJECTOR DIAMETER (M)
C    SIDE    SQUARE PROJECTOR SIDE LENGTH (M)
C    SIDE1   RECTANGULAR PROJECTOR SIDE LENGTH (M)
C    SIDE2   RECTANGULAR PROJECTOR SIDE LENGTH (M)
C    EFL     ENDFIRE LINE LENGTH (M)
C    BW0     3-DB BEAMWIDTH OF ARBITRARY AXISYMMETRIC BEAM (DEG)
C    FZERO   MEAN PRIMARY FREQUENCY (KHZ)
C    FDIFF   DIFFERENCE FREQUENCY (KHZ)
C    SLZERO  RMS PRIMARY SOURCE LEVEL, ONE-COMPONENT (DB//UPA-M)
C    R       RANGE (M) IF POSITIVE. NEGATIVE VALUE IMPLIES FARFIELD
C            COMPUTATION. IF 0 .GT. R .LT. 1, ONLY SOURCE LEVELS
C            CAN BE OBTAINED (I.E., RUNTYP MUST BE 'S').
C    TEMP    WATER TEMPERATURE (DEGREES CELSIUS)
C    SAL     SALINITY (PARTS PER THOUSAND)
C    DEPTH   SOURCE DEPTH (M)
C    PH      USUALLY BETWEEN 7.0 AND 9.0
C FOR AN ARBITRARY AXISYMMETRIC PRIMARY BEAM, THE BEAM PATTERN 
C IS ENTERED AS A PRODUCT PATTERN, I.E., PRIMARY PATTERN BEARING
C DEVIATION LOSSES OF 4 DB AND 6 DB AT THE TWO PRIMARY FREQUENCIES
C ARE ENTERED AS ONE POINT WITH BPSQ = 10 DB.  POINTS AT 0 DEG
C (WHERE BPSQ MUST BE 0 DB) AND AT 180 DEG MUST BE INCLUDED.
C    N0      NUMBER OF POINTS IN BPSQ (MUST BE 200 OR LESS)
C    ANGLE   WITH RESPECT TO PRIMARY AXIS (DEG)
C    BPSQ    SUM OF PRODUCT PATTERN BEARING DEVIATION LOSSES (DB)
C  OUTPUTS:
C    CSPEED  SOUND SPEED (M/S)
C    ALPHA   PRIMARY ABSORPTION COEFFICIENT (DB/M)
C    SLONES  SCALED PRIMARY SOURCE LEVEL CORRESPONDING TO ONE-
C            COMPONENT SHOCK FORMATION AT RZERO (DB//UPA-M-KHZ)
C    WAVEL   PRIMARY WAVELENGTH (M)
C    AREA    AREA OF CIRCULAR, SQUARE, OR RECTANGULAR SOURCE (M**2)
C    ASPECT  ASPECT RATIO OF RECTANGULAR PROJECTOR 
C    RZERO   PRIMARY RAYLEIGH LENGTH (M)
C    SLZERS  SCALED PRIMARY SOURCE LEVEL (DB//UPA-M-KHZ)
C    CHIDB   20*LOG10(CHI)=SLZERS-SLONES WHERE CHI = RZERO/(PLANE 
C            WAVE SHOCK-FORMATION LENGTH)
C    ALFAR0  ALPHA*RZERO (DB)
C    DOWNSR  FZERO/FDIFF
C    R0K0    KZERO*RZERO WHERE KZERO = 2*PI/WAVEL
C    DIZERO  PRIMARY DIRECTIVITY INDEX = 10*LOG10(2*R0K0)
C    RANGE   R/RZERO
C    BWEF    WESTERVELT 3-DB BEAMWIDTH (DEG)
C    GAIN    APPARENT PARAMETRIC GAIN (DB) = SL-SLZERO
C    PHASE   PHASE OF PARAMETRIC GAIN (DEG)
C    SL      APPARENT DIFFERENCE-FREQUENCY RMS SOURCE LEVEL (DB//
C            UPA-M)
C    SPL     RMS SOUND PRESSURE LEVEL OF DIFFERENCE FREQUENCY AT R
C            (DB//UPA)
C    PHI     AZIMUTHAL ANGLE ABOUT RECTANGULAR PROJECTOR AXIS 
C            (DEG).  PHI = 0 CORRESPONDS TO LONG SIDE DIRECTION.
C    BW0     PRIMARY 3-DB BEAMWIDTH (DEG)
C    THETA   ANGLE WITH RESPECT TO PROJECTOR AXIS (DEG)
C    BDGAP   APERTURE-CORRECTED BEARING DEVIATION GAIN (DB)
C RZERO=PROJECTOR AREA/PRIMARY WAVELENGTH FOR CIRCULAR,SQUARE,
C AND RECTANGULAR PROJECTORS. RZERO=PROJECTOR LENGTH/PI FOR 
C ENDFIRE CASE. RZERO IS OBTAINED FROM BW0 INPUT FOR ARBITRARY BEAM
C CASE. FOR RECTANGULAR PROJECTORS, PHI = 0 YIELDS BROADER PATTERNS
C AND PHI = 90 DEGREES YIELDS NARROWER PATTERNS. FOR ARBITRARY
C AXISYMMETRIC BEAMS, THE SQUARE OF THE APERTURE FACTOR, DAPSQ,
C IS DERIVED FROM THE INPUT PRIMARY PRODUCT PATTERN, BPSQ, BY
C SCALING, I.E., DAPSQ(THETA) = BPSQ(THETA*F/F0).
      CHARACTER*1 RUNTYP,SHAPE
      REAL MMBSJ1
      DOUBLE PRECISION TWOALF,RK,CONST3
      COMMON/BLK1/TWOALF
      COMMON/BLK2/RK
      COMMON/TAN/RANGE
      COMMON/BLUE/ASPECT,ISHAPE
      COMMON/YELLOW/CONST3
      COMMON/ODRAB1/FZERO,SLZERO,BW0,BW1,BW2,RZERO,ALFAR0
      COMMON/ODRAB2/FDIFF,SL,BEAMW,R
      COMMON/WHT/C(24),W(24)
      COMMON/GREEN/ICOUNT
      COMMON/BEIGE/A,BHALF,NPHI,ANS3,ANS4
      COMMON/GREY/BWEFR,BW0R,STH,CTH,PI,ANGLE(200),BPSQ(200)
      COMMON/PINK/R0K0,PHIR
      COMMON/PURPLE/XARRAY(200),YARRAY(200),ZARRAY(200)
      PI=3.14159265
      E=EXP(1.0)
      DEGRAD=PI/180.
      OPEN(13,NAME='OUTPUT.DAT',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     &FORM='FORMATTED')
      CALL QGM48
C NEW INPUT DRIVER (OCTOBER, 1989):
 1001 PRINT 90
   90 FORMAT(1H0)
      PRINT 91 
   91 FORMAT(' CONVOL3 -- NUMERICAL INPUTS REQUIRE DECIMAL POINT')
	  WRITE(13,3000)
 3000 FORMAT(' CONVOL3')
      PRINT 41
      PRINT 42
      PRINT 43
      PRINT 44
      PRINT 45
   41 FORMAT(' TYPE OF RUN (S,W,P, OR T):')
   42 FORMAT('   S = SOURCE LEVEL ONLY')
   43 FORMAT('   W = SOURCE LEVEL AND BEAMWIDTH')
   44 FORMAT('   P = SOURCE LEVEL, BEAMWIDTH, AND BEAM PATTERN')
   45 FORMAT('   T = TERMINATE RUN',/)
      READ 46, RUNTYP
   46 FORMAT(A1)
      IF(RUNTYP.NE.'S'.AND.RUNTYP.NE.'s') THEN
	IF(RUNTYP.NE.'W'.AND.RUNTYP.NE.'w') THEN
	  IF(RUNTYP.NE.'P'.AND.RUNTYP.NE.'p') THEN
	    IF(RUNTYP.NE.'T'.AND.RUNTYP.NE.'t') GO TO 1007
	  ELSE 
	    CONTINUE
	  END IF
	ELSE
	  CONTINUE
	END IF
      ELSE 
	CONTINUE
      END IF
      IF(RUNTYP.EQ.'S'.OR.RUNTYP.EQ.'s') NOBEAM=2
      IF(RUNTYP.EQ.'W'.OR.RUNTYP.EQ.'w') NOBEAM=1
      IF(RUNTYP.EQ.'P'.OR.RUNTYP.EQ.'p') NOBEAM=0
      IF(RUNTYP.EQ.'T'.OR.RUNTYP.EQ.'t') ISHAPE=-1
      IF(ISHAPE.LT.0) GO TO 900
      PRINT 47
   47 FORMAT(' PROJECTOR SHAPE (C,S,R,E, OR A):')
      PRINT 48
      PRINT 49
      PRINT 50
      PRINT 51
      PRINT 52
   48 FORMAT('   C = CIRCULAR PROJECTOR')
   49 FORMAT('   S = SQUARE PROJECTOR')
   50 FORMAT('   R = RECTANGULAR PROJECTOR')
   51 FORMAT('   E = ENDFIRE LINE')      
   52 FORMAT('   A = ARBITRARY AXISYMMETRIC BEAM',/)
      READ 46, SHAPE
      IF(SHAPE.NE.'C'.AND.SHAPE.NE.'c') THEN
	IF(SHAPE.NE.'S'.AND.SHAPE.NE.'s') THEN
	  IF(SHAPE.NE.'R'.AND.SHAPE.NE.'r') THEN
	    IF(SHAPE.NE.'E'.AND.SHAPE.NE.'e') THEN
	      IF(SHAPE.NE.'A'.AND.SHAPE.NE.'a') GO TO 1007
	    ELSE
	      CONTINUE
	    END IF
	  ELSE
	    CONTINUE
	  END IF
	ELSE
	  CONTINUE
	END IF
      ELSE
	CONTINUE
      END IF
      IF(SHAPE.EQ.'C'.OR.SHAPE.EQ.'c') THEN
	ISHAPE=0
	PRINT 53
	READ 17, DIAM
	WRITE(13,3001) DIAM
	IF(DIAM.LE.0.) GO TO 1007
	AREA=0.25*PI*(DIAM**2)
      ELSE
	CONTINUE
      END IF
   53 FORMAT(' DIAMETER (M)',/)
 3001 FORMAT(' DIAMETER = ',F7.3,' M')
      IF(SHAPE.EQ.'S'.OR.SHAPE.EQ.'s') THEN
	ISHAPE=1
	PRINT 54
	READ 17, SIDE
	    WRITE(13,3002) SIDE
	IF(SIDE.LE.0.) GO TO 1007
	AREA=SIDE**2
      ELSE
	CONTINUE
      END IF
   54 FORMAT(' LENGTH OF ONE SIDE (M)',/)
 3002 FORMAT(' LENGTH OF ONE SIDE = ',F7.3,' M')
      IF(SHAPE.EQ.'R'.OR.SHAPE.EQ.'r') THEN
	ISHAPE=2
	PRINT 54
	READ 17, SIDE1
	WRITE(13,3002) SIDE1
	IF(SIDE1.LE.0.) GO TO 1007
	PRINT 55
	READ 17, SIDE2
	WRITE(13,3003) SIDE2
	IF(SIDE2.LE.0.) GO TO 1007
	AREA=SIDE1*SIDE2
	ASPECT=SIDE1/SIDE2
	IF(ASPECT.LT.1.0) ASPECT=1.0/ASPECT
      ELSE 
	CONTINUE
      END IF
   55 FORMAT(' LENGTH OF OTHER SIDE (M)',/)
 3003 FORMAT(' LENGTH OF OTHER SIDE = ',F7.3,' M')
      IF(SHAPE.EQ.'E'.OR.SHAPE.EQ.'e') THEN
	ISHAPE=3
	PRINT 56
	READ 17, EFL
	WRITE(13,3004) EFL
	IF(EFL.LE.0.) GO TO 1007
	RZERO=EFL/PI
      ELSE
	CONTINUE
      END IF
   56 FORMAT(' LENGTH (M)',/)
 3004 FORMAT(' LENGTH = ',F7.3,' M')
      IF(SHAPE.EQ.'A'.OR.SHAPE.EQ.'a') THEN
	ISHAPE=4
	PRINT 57
	READ 17, BW0
	WRITE(13,3005) BW0
	BW0R=DEGRAD*BW0
	IF(BW0R.LE.0.) GO TO 1007
	IF(BW0R.GE.PI) GO TO 1007
      ELSE
	CONTINUE
      END IF
   57 FORMAT(' 3-DB BEAMWIDTH (DEG)',/)
 3005 FORMAT(' 3-DB BEAMWIDTH = ',F6.2,' DEG')
      PRINT 58
   58 FORMAT(' MEAN PRIMARY FREQUENCY (KHZ)',/)
      READ 17, FZERO
      WRITE(13,3006) FZERO
 3006 FORMAT(' MEAN PRIMARY FREQUENCY = ',F7.3,' KHZ')
      IF(FZERO.LE.0.) GO TO 1007
      PRINT 59
   59 FORMAT(' DIFFERENCE FREQUENCY (KHZ)',/)
      READ 17, FDIFF
	  WRITE(13,3007) FDIFF
 3007 FORMAT(' DIFFERENCE FREQUENCY = ',F7.3,' KHZ')
      IF(FDIFF.LE.0.) GO TO 1007
      DOWNSR=FZERO/FDIFF
      IF(DOWNSR.LE.1.5) GO TO 1007
      PRINT 60
   60 FORMAT(' RMS SOURCE LEVEL, ONE PRIMARY TONE (DB//UPA-M)',/)
      READ 17, SLZERO
      WRITE(13,3008) SLZERO
 3008 FORMAT(' RMS SOURCE LEVEL, ONE TONE = ',F7.1,' DB//UPA-M')
      PRINT 61
   61 FORMAT(' RANGE (M) (FOR INFINITE RANGE, USE NEGATIVE VALUE)',/)
      READ 17, R
	  WRITE(13,3009) R
 3009 FORMAT(' RANGE = ',F7.3,' M')
      IF(R.EQ.0.) GO TO 1007
C WATER CONDITIONS
      PRINT 62
   62 FORMAT(' TEMPERATURE (CELSIUS)',/)
      READ 17, TEMP
      WRITE(13,3010) TEMP
 3010 FORMAT(' TEMPERATURE = ',F6.1,' CELSIUS')
      PRINT 63
   63 FORMAT(' SALINITY (PARTS PER THOUSAND)',/)
      READ 17, SAL
      WRITE(13,3011) SAL
 3011 FORMAT(' SALINITY = ',F6.1,' PARTS PER THOUSAND')
      IF(SAL.LT.0.) GO TO 1007
      PRINT 64
   64 FORMAT(' DEPTH (M)',/)
      READ 17, DEPTH
      WRITE(13,3012) DEPTH
 3012 FORMAT(' DEPTH = ',F7.1,' M')
      IF(DEPTH.LT.0.) GO TO 1007
      PRINT 65
   65 FORMAT(' PH (USE 8.0 IN CASE OF DOUBT)',/)
      READ 17, PH
	  WRITE(13,3013) PH
 3013 FORMAT(' PH = ',F5.1)
      IF(PH.LT.0.0.OR.PH.GT.14.) GO TO 1007
C SOUND SPEED, ACCORDING TO MEDWIN:
      CSPEED=0.016*DEPTH+(1.34-0.01*TEMP)*(SAL-35.)
      CSPEED=CSPEED+0.00029*(TEMP**3)-0.055*(TEMP**2)
      CSPEED=CSPEED+4.6*TEMP+1449.2
C ABSORPTION, ACCORDING TO MELLEN:
      A1=0.5*10.**(-0.00005*DEPTH)
      A2=0.1*10.**(PH-8.0)
      A3=0.3*A2
      EF1=50.*10.**(TEMP/60.)
      EF2=0.9*10.**(TEMP/70.)
      EF3=4.5*10.**(TEMP/30.)
      AZERO=49./10.**((DEPTH/62000.)+(TEMP/54.)+5.)
      ALPHA=A3*EF3/(EF3**2+FZERO**2)
      ALPHA=ALPHA+A2*EF2/(EF2**2+FZERO**2)
      ALPHA=ALPHA+A1*EF1/(EF1**2+FZERO**2)
      ALPHA=AZERO+ALPHA*SAL/35.
      ALPHA=0.001*ALPHA*FZERO**2 
C SCALED SOURCE LEVEL CORRESPONDING TO ONE-COMPONENT SHOCK
C FORMATION AT RZERO:
      SLONES=(0.02*TEMP+0.2)*SAL/35.
      IF(TEMP.LE.10.) THEN
	SLONES=SLONES+0.0001*DEPTH+0.01*TEMP+280.1
      ELSE 
	SLONES=SLONES+0.0002*DEPTH+0.02*TEMP+280.0
      END IF
C CALCULATE INPUT PARAMETERS:
      SLZERS=SLZERO+20.*ALOG10(FZERO)
      CHIDB=SLZERS-SLONES
      IF(CHIDB.GT.10.) THEN
	PRINT 92
	WRITE(13,92)
	GO TO 1007
      ELSE
	CONTINUE
      END IF
   92 FORMAT(' PRIMARY SOURCE LEVEL AND/OR FREQUENCY TOO
     * LARGE FOR ACCURATE COMPUTATION')
      WAVEL=0.001*CSPEED/FZERO
      IF(ISHAPE.LE.2) RZERO=AREA/WAVEL
      IF(ISHAPE.EQ.4) RZERO=(2.62/PI)*WAVEL/(SIN(BW0R))**2
      R0K0=2.*PI*RZERO/WAVEL
      ALFAR0=ALPHA*RZERO
      RANGE=R/RZERO
      IF(ISHAPE.NE.2) ASPECT=1.0
   17 FORMAT(E15.6)
      IF(ISHAPE.GT.4) GO TO 1007
      IF(ALFAR0.LE.0.0) GO TO 1007
      IF(DOWNSR.LE.0.0) GO TO 1007
      IF(R0K0.LT.1.4) GO TO 1007
      IF(RANGE.EQ.0.0) GO TO 1007
      IF(RANGE.GT.0.0.AND.RANGE.LE.1.0) THEN
	IF(RUNTYP.NE.'S'.AND.RUNTYP.NE.'s') GO TO 1007
      ELSE
	CONTINUE
      END IF
      IF(ASPECT.LT.1.0) GO TO 1007
      BWEFR=4.0*ASIN(SQRT(ALFAR0*DOWNSR/(20.*ALOG10(E)*R0K0)))
      BWEF=BWEFR/DEGRAD
      IF(ISHAPE.EQ.0) BW0R=2.0*ASIN(SQRT(1.31/R0K0))
      IF(ISHAPE.EQ.1) BW0R=2.0*ASIN(SQRT(1.23/R0K0))
      IF(ISHAPE.EQ.2) BW0R=2.0*ASIN(SQRT(1.23/(R0K0*ASPECT)))
      IF(ISHAPE.EQ.3) BW0R=4.0*ASIN(SQRT(0.442/R0K0))
      IF(ISHAPE.NE.4) GO TO 1008
      PRINT 66
      WRITE(13,66)
   66 FORMAT(' NUMBER OF POINTS IN PRIMARY BPSQ (FORMAT = I3)',/)
      READ 28, NO
   28 FORMAT(I3)
      PRINT 31
      WRITE(13,31)
   31 FORMAT(1X,'ANGLE(DEG)',2X,'BPSQ(DB)')
      DO 1010 M=1,NO
      PRINT 67, M
      WRITE(13,67) M
   67 FORMAT(1X,I3)
      READ 29, ANGLE(M),BPSQ(M)
   29 FORMAT(2E10.2)
      WRITE(13,3014) ANGLE(M),BPSQ(M)
 3014 FORMAT(1X,2F10.2)
      IF(M.EQ.1.AND.ANGLE(1).NE.0.) GO TO 1007
      IF(M.GT.1.AND.ANGLE(M).LE.ANGLE(M-1)) GO TO 1007
 1010 CONTINUE
      IF(ANGLE(NO).NE.180.) GO TO 1007
      DO 1011 M=1,NO
      ANGLE(M)=DEGRAD*ANGLE(M)
      BPSQ(M)=10.**(-0.05*BPSQ(M))
 1011 CONTINUE
      GO TO 1009
 1008 BW0=BW0R/DEGRAD
 1009 NTHETA=1+INT(1.0/BW0)
      ENN=FLOAT(NTHETA)
      CHI=10.**(0.05*CHIDB)
      RK=DBLE(R0K0*RANGE/DOWNSR)
      CONST3=DBLE(3.0*(CHI/PI)**2)
      TWOALF=DBLE(0.1*ALFAR0*RANGE/ALOG10(E))
      COEFF=CHI*RANGE*R0K0/(4.0*PI*DOWNSR*DOWNSR)
      CALL TABLE
      PHIR=0.0
      GO TO 1006
 1005 PHIR=PI*0.5
C     START OF POINT GENERATION
 1006 NPOINT=0
      IF(NOBEAM.EQ.0.OR.NOBEAM.EQ.1) NMAX=69
      IF(NOBEAM.EQ.2) NMAX=1
      DO 1041 N=1,NMAX
      IF(N.LE.10) THETA=FLOAT(N-1)*.2
      IF(N.GT.10) THETA=FLOAT(N-9)
      THETAR=THETA*DEGRAD
      CTH=COS(THETAR)
      STH=SIN(THETAR)
      ANS1=0.0
      ANS2=0.0
      ANS3=0.0
      ANS4=0.0
      NPHI=0
      IF(BWEF.GT.BW0) GO TO 1030
      IF(THETA.LT.0.5*BWEF) GO TO 1031
      IF(THETA.LT.90.-0.5*BWEF) GO TO 1032
      GO TO 1033
C  INTEGRAL FROM 0 TO PI/2:
 1030 B=0.5*PI/ENN
      BHALF=0.5*B
      A=0.5*PI-BHALF
      DO 1022 J=1,NTHETA
      CALL PROC01
      A=A-B
 1022 CONTINUE
      ANS1=ANS3*B
      ANS2=ANS4*B
      GO TO 1034
C  INTEGRAL FROM BWEFR TO PI/2:
 1031 B=(0.5*PI-BWEFR)/ENN
      BHALF=0.5*B
      A=0.5*PI-BHALF
      DO 1027 J=1,NTHETA
      CALL PROC01
      A=A-B
 1027 CONTINUE
      ANS1=ANS3*B
      ANS2=ANS4*B
C  INTEGRAL FROM 0 TO BWEFR:
      ANS3=0.0
      ANS4=0.0
      B=BWEFR
      BHALF=0.5*B
      A=BHALF
      CALL PROC01
      ANS3=ANS3*B
      ANS4=ANS4*B
C  ACCUMULATION FOR TOTAL INTEGRAL:
      ANS1=ANS1+ANS3
      ANS2=ANS2+ANS4
      GO TO 1034
 1032 K=(NTHETA+1)/2
      L=NTHETA-K
      IF(L.EQ.0) L=1
      DKAY=FLOAT(K)
      DELL=FLOAT(L)
C  INTEGRAL FROM (THETAR+BWEFR/2) TO PI/2:
      B=(0.5*(PI-BWEFR)-THETAR)/DELL
      BHALF=0.5*B
      A=0.5*PI-BHALF
      DO 1035 J=1,L
      CALL PROC01
      A=A-B
 1035 CONTINUE
      ANS1=ANS3*B
      ANS2=ANS4*B
C  INTEGRAL FROM 0 TO (THETAR-BWEFR/2):
      ANS3=0.0
      ANS4=0.0
      B=(THETAR-0.5*BWEFR)/DKAY
      BHALF=0.5*B
      A=THETAR-0.5*BWEFR-BHALF
      DO 1037 J=1,K
      CALL PROC01
      A=A-B
 1037 CONTINUE
      ANS3=ANS3*B
      ANS4=ANS4*B
C  ACCUMULATION:
      ANS1=ANS1+ANS3
      ANS2=ANS2+ANS4
C  INTEGRAL FROM (THETAR-BWEFR/2) TO (THETAR+BWEFR/2):
      ANS3=0.0
      ANS4=0.0
      B=BWEFR
      BHALF=0.5*B
      A=THETAR
      CALL PROC01
      ANS3=ANS3*B
      ANS4=ANS4*B
C  ACCUMULATION FOR TOTAL INTEGRAL:
      ANS1=ANS1+ANS3
      ANS2=ANS2+ANS4
      GO TO 1034
C  INTEGRAL FROM 0 TO (PI/2-BWEFR):
 1033 B=(0.5*PI-BWEFR)/ENN
      BHALF=0.5*B
      A=0.5*PI-BWEFR-BHALF
      DO 1040 J=1,NTHETA
      CALL PROC01
      A=A-B
 1040 CONTINUE
      ANS1=ANS3*B
      ANS2=ANS4*B
C  INTEGRAL FROM (PI/2-BWEFR) TO PI/2:
      ANS3=0.0
      ANS4=0.0
      B=BWEFR
      BHALF=0.5*B
      A=0.5*PI-BHALF
      CALL PROC01
      ANS3=ANS3*B
      ANS4=ANS4*B
C  ACCUMULATION FOR TOTAL INTEGRAL:
      ANS1=ANS1+ANS3
      ANS2=ANS2+ANS4
 1034 PHASE=ATAN2(ANS2,ANS1)
      PHASE=PHASE/DEGRAD
      IF(N.GT.1) GO TO 1020
      RGAIN=10.*ALOG10(ANS1*ANS1+ANS2*ANS2)
      FASE=PHASE
      GAIN=RGAIN+10.*ALOG10(COEFF*COEFF)
      IF(PHIR.EQ.0.0) THEN
	PRINT 68, CSPEED
	WRITE(13,68) CSPEED
   68 FORMAT(' SOUND SPEED = ',F6.1,' M/S')
	PRINT 69, ALPHA
	WRITE(13,69) ALPHA
   69 FORMAT(' ALPHA = ',E9.3,' DB/M')
	PRINT 70, SLONES
	WRITE(13,70) SLONES
   70 FORMAT(' SLONESTAR = ',F5.1,' DB//UPA-M-KHZ')
	PRINT 71, WAVEL
	WRITE(13,71) WAVEL
   71 FORMAT(' PRIMARY WAVELENGTH = ',E9.3,' M')
	IF(ISHAPE.LE.2) PRINT 72, AREA
	IF(ISHAPE.LE.2) WRITE(13,72) AREA
   72 FORMAT(' PROJECTOR AREA = ',F7.4,' M**2')
	IF(ISHAPE.EQ.2) PRINT 73, ASPECT
	    IF(ISHAPE.EQ.2) WRITE(13,73) ASPECT
   73 FORMAT(' ASPECT RATIO = ',F5.2)
	PRINT 74, RZERO
	WRITE(13,74) RZERO
   74 FORMAT(' RZERO = ',F7.3,' M')
	PRINT 75, SLZERS
	WRITE(13,75) SLZERS
   75 FORMAT(' SLZEROSTAR = ',F5.1,' DB//UPA-M-KHZ')
	PRINT 76, CHIDB
	    WRITE(13,76) CHIDB
   76 FORMAT(' 20*LOG(CHI) = ',F5.1,' DB')
	PRINT 77, ALFAR0
	    WRITE(13,77) ALFAR0
   77 FORMAT(' ALPHA*RZERO = ',E9.3,' DB')
	PRINT 78, DOWNSR
	    WRITE(13,78) DOWNSR
   78 FORMAT(' FZERO/FDIFF = ',F6.2)
	PRINT 79, R0K0
	    WRITE(13,79) R0K0
   79 FORMAT(' KZERO*RZERO = ',F6.0)
	PRINT 80, 10.*ALOG10(2.*R0K0)
	    WRITE(13,80) 10.*ALOG10(2.*R0K0)
   80 FORMAT(' DIZERO = ',F4.1,' DB')
	IF(RANGE.LT.0.0) PRINT 81
	    IF(RANGE.LT.0.0) WRITE(13,81)
   81 FORMAT(' INFINITE RANGE')
	IF(RANGE.GT.0.0) PRINT 82, RANGE
	    IF(RANGE.GT.0.0) WRITE(13,82) RANGE
   82 FORMAT(' R/RZERO = ',F7.2)
	PRINT 83, BWEF
	    WRITE(13,83) BWEF
   83 FORMAT(' WESTERVELT BEAMWIDTH = ',F6.3,' DEG')
	PRINT 19, GAIN
	    WRITE(13,19) GAIN
   19 FORMAT(' APPARENT PARAMETRIC GAIN = ',F6.1,' DB')
	PRINT 85, PHASE
	    WRITE(13,85) PHASE
   85 FORMAT(' PHASE OF PARAMETRIC GAIN = ',F5.1,' DEG')
	SL=SLZERO+GAIN
	PRINT 86, SL
	    WRITE(13,86) SL
   86 FORMAT(' APPARENT SOURCE LEVEL = ',F5.1,' DB//UPA-M')
	IF(RANGE.GT.0.0) THEN
	  SPL=SL-20.*ALOG10(R)
	  PRINT 87, SPL
	      WRITE(13,87) SPL
	ELSE
	  CONTINUE
	END IF
   87 FORMAT(' SOUND PRESSURE LEVEL = ',F5.1,' DB//UPA')  
	IF(ISHAPE.EQ.2) PRINT 88, PHIR/DEGRAD
	    IF(ISHAPE.EQ.2) WRITE(13,88) PHIR/DEGRAD
   88 FORMAT(' PHI = ',F4.1,' DEG')
      ELSE
	PRINT 90             
	    WRITE(13,90)
	PRINT 88, PHIR/DEGRAD
	    WRITE(13,88) PHIR/DEGRAD
      END IF
      IF(ISHAPE.NE.2) THEN
	PRINT 84, BW0
	    WRITE(13,84) BW0
      ELSE
	BW1=2.0*ASIN(SQRT(1.23*ASPECT/R0K0))/DEGRAD
	BW2=BW0
	IF(PHIR.EQ.0.0) THEN
	  IF(NOBEAM.EQ.2) THEN
	    PRINT 84, BW1
		WRITE(13,84) BW1
	    PRINT 84, BW2
		WRITE(13,84) BW2
	  ELSE
	    PRINT 84, BW1
		WRITE(13,84) BW1
	  END IF
	ELSE
	  PRINT 84, BW2
	      WRITE(13,84) BW2
	END IF
      END IF
   84 FORMAT(' PRIMARY BEAMWIDTH = ', F6.3,' DEG')
      IF(NOBEAM.EQ.2) GO TO 1042
      PRINT 13
	  WRITE(13,13)
   13 FORMAT(1H0,'THETA(DEG)',2X,'BDGAP(DB)')
 1020 BDG=10.*ALOG10(ANS1*ANS1+ANS2*ANS2)-RGAIN
      IF(N.EQ.1) GO TO 1017
      IF(ISHAPE.EQ.0.OR.ISHAPE.EQ.3) GO TO 1014
      IF(ISHAPE.EQ.4) GO TO 1012
      ARG11=SQRT(0.5*R0K0*PI)*STH/DOWNSR
      IF(ISHAPE.EQ.1) GO TO 1015
      RTAS=SQRT(ASPECT)
      IF(PHIR.EQ.0.0) GO TO 1016
      ARG11=ARG11*RTAS
      GO TO 1015
 1016 ARG11=ARG11/RTAS
 1015 DAP=SIN(ARG11)/ARG11
      GO TO 1018
 1014 ARG11=SQRT(2.0*R0K0)*STH/DOWNSR
      DAP=2.0*MMBSJ1(ARG11)/ARG11
      ARG11=0.5*PI*R0K0*(1.0-CTH)/DOWNSR
      IF(N.LE.11) ARG11=0.25*PI*R0K0*(THETAR**2)/DOWNSR
      IF(ISHAPE.EQ.3) DAP=SIN(ARG11)/ARG11
 1018 DAPSQ=DAP**2
      GO TO 1013
 1012 M=1
 1024 STRECH=DOWNSR*ANGLE(M)
      IF(THETAR.LE.STRECH) GO TO 1025
      M=M+1
      GO TO 1024
 1025 M2=M
      M1=M-1
      IF(M1.EQ.0) GO TO 1026
      DAPSQ=(BPSQ(M2)-BPSQ(M1))*((THETAR/DOWNSR)-ANGLE(M1))
      DAPSQ=DAPSQ/(ANGLE(M2)-ANGLE(M1))+BPSQ(M1)
      GO TO 1013
 1026 DAPSQ=BPSQ(1)
 1013 IF(DAPSQ.EQ.0.0) DAPSQ=1.0E-08
      BDGAP=BDG+10.*ALOG10(DAPSQ)
      GO TO 1019
 1017 BDGAP=0.0
 1019 PRINT 14, THETA,BDGAP
	  WRITE(13,14) THETA,BDGAP
   14 FORMAT(1X,F5.1,7X,F6.1)
      IF(BDGAP.LE.-3.0.AND.ZARRAY(NPOINT+68).GT.-3.0) THEN
	DIFFDB=ZARRAY(NPOINT+68)-BDGAP
	BEAMW=(ZARRAY(NPOINT+68)+3.0)/DIFFDB
	BEAMW=BEAMW*(THETA-XARRAY(NPOINT+68))
	BEAMW=2.*(BEAMW+XARRAY(NPOINT+68))
	PRINT 89, BEAMW
	    WRITE(13,89) BEAMW
	IF(NOBEAM.EQ.1) GO TO 2001
      ELSE
	CONTINUE
      END IF
   89 FORMAT(' 3-DB BEAMWIDTH = ',F4.1,' DEG')
C      REMOVED FORM PC VERSION    F.R.S
      CALL MMSTOR(THETA,BDG,BDGAP,NPOINT)
 1042 CONTINUE
 1041 CONTINUE
 2001 IF(NOBEAM.EQ.0) THEN
	NAPFAC=1
C        REMOVED FROM PC VERSION    F.R.S.
C        CALL MMPLOT
      ELSE
	CONTINUE
      END IF
      IF(PHIR.EQ.0.0) THEN
	IF(ISHAPE.EQ.2) THEN
	  IF(NOBEAM.EQ.2) THEN
	    CONTINUE
	  ELSE
	    GO TO 1005
	  END IF
	ELSE
	  CONTINUE
	END IF
      ELSE
	CONTINUE
      END IF
      IF(NOBEAM.NE.0) PRINT 34
      IF(NOBEAM.NE.0) WRITE(13,34)
   34 FORMAT(1X,'NO BEAM PATTERNS REQUESTED')
      GO TO 1001
  900 CONTINUE
      STOP
 1007 PRINT 21
	  WRITE(13,21)
   21 FORMAT(1X,'BAD INPUT.  NEXT CASE.')
      GO TO 1001
      END
C
C
C
C  PROCEDURE PROC01.  IN ORDER TO MAKE THIS PROGRAM RUN ON THE VAX
C COMPUTER, THE FOLLOWING SUBROUTINE WAS CONVERTED FROM INTERNAL
C TO EXTERNAL TO THE MAIN PROGRAM.  TWO COMMON BLOCKS WERE ADDED:
C          GREEN: ICOUNT
C          BEIGE: A, BHALF, NPHI, ANS3, ANS4
C WITH GREEN COMMON TO MAIN, PROC01, AND FCT AND WITH BEIGE
C COMMON TO MAIN AND PROC01.  IN ADDITION, THE WHT COMMON
C BLOCK, CONTAINING W(I) AND C(I), WAS MADE COMMON TO PROC01
C (IN ADDITION TO MAIN, QGM48, AND FCT).  10/3/88
      SUBROUTINE PROC01
      COMMON/WHT/C(24),W(24)
      COMMON/GREEN/ICOUNT
      COMMON/BEIGE/A,BHALF,NPHI,ANS3,ANS4
      DO 1023 I=1,24
      CALL FCT(A+BHALF*C(I),ARG1,ARG2)
      NPHI=NPHI+ICOUNT
      ARG3=ARG1
      ARG4=ARG2
      CALL FCT(A-BHALF*C(I),ARG1,ARG2)
      NPHI=NPHI+ICOUNT
      ANS3=ANS3+W(I)*(ARG3+ARG1)*0.5
 1023 ANS4=ANS4+W(I)*(ARG4+ARG2)*0.5
      RETURN
      END
C
C
C
      SUBROUTINE TABLE
C THIS SUBPROGRAM TABULATES EXP(JKR)*I(COSNU) FOR 0.0001.LE.GNU.LE.
C 3.14, WITH REAL PARTS STORED IN VALUE1(N) AND IMAGINARY PARTS
C STORED IN VALUE2(N).  THE INDEX N IS RELATED TO GNU BY
C GNU = FLOAT(N)/10000      1.LE.N.LE. 10
C          FLOAT(N-9)/1000    10.LE.N.LE. 19
C          FLOAT(N-18)/100    19.LE.N.LE.118
C          FLOAT(N-68)/50    118.LE.N.LE.225
C COSNU IS NEGATIVE FOR GNU.GT.PI/2.
C        INPUTS    TWOALF=2*ALPHA*R
C                  RK=KR
C                  RANGE=R/R0
C        OUTPUTS   U0=TWOALF*COSNU
C                  V0=KR*(1-COSNU)
C                  CONST1=COSNU*R/R0
C                  VALUE1(225)
C                  VALUE2(225)
C                  AKOTAL=ALPHA/(2*K)
C                  BSQ=B**2     (COMPLEX)
      EXTERNAL FNC
      COMPLEX*16 BSQ
      DOUBLE PRECISION A,B,E,ADPSBC,FNC
      DOUBLE PRECISION U0,V0,TWOALF,RK,CONST1,AKOTAL
      COMMON/BLK1/TWOALF
      COMMON/BLK2/RK
      COMMON/BLK3/U0
      COMMON/TAN/RANGE
      COMMON/RED/VALUE1(240),VALUE2(240)
      COMMON/BROWN/CONST1,AKOTAL
      COMMON/FUCIA/BSQ,V0
      YMAX=20.
      EPSI=1.0E-04
      DO 201 N=1,225
      IF(N-10) 203,203,204
  203 GNU=FLOAT(N)*1.0E-04
      GO TO 205
  204 IF(N-19) 208,208,209
  208 GNU=FLOAT(N-9)*1.0E-03
      GO TO 205
  209 IF(N-118) 212,212,213
  212 GNU=FLOAT(N-18)*0.01
      GO TO 205
  213 GNU=FLOAT(N-68)*0.02
  205 COSNU=COS(GNU)
      U0=TWOALF*DBLE(COSNU)
      V0=RK*DBLE(1.0-COSNU)
      IF(N.LT.19) V0=RK*DBLE((GNU**6)/720.-(GNU**4)/24.+0.5*(GNU**2))
      CONST1=DBLE(COSNU)*RANGE
      AKOTAL=RK/TWOALF
      BSQ=DCMPLX(1D0,2D0*AKOTAL)*DBLE(TWOALF**2)*DBLE((SIN(GNU))**2)
      A=0D0
      B=DBLE(YMAX)
      E=DBLE(EPSI)
      VALUE1(N)=SNGL(ADPSBC(A,B,FNC,1,E,NP1))
      A=0D0
      B=DBLE(YMAX)
      E=DBLE(EPSI)
      VALUE2(N)=SNGL(ADPSBC(A,B,FNC,2,E,NP2))
      IF(RANGE.GT.0.0) GO TO 201
      VEE=SNGL(V0/TWOALF)
      DEN=-1./(SNGL(TWOALF)*(1.+VEE**2))
      V1=VALUE1(N)
      V2=VALUE2(N)
      VALUE1(N)=(V1+VEE*V2)*DEN
      VALUE2(N)=(V2-VEE*V1)*DEN
  201 CONTINUE
      RETURN
      END
C
C
C
      FUNCTION ADPSBC(A,B,FNC,INDEX,EPS,NP)
C**********PROGRAMMED BY M. J. GOLDSTEIN**********
C***************************************************************
C*****THIS DOUBLE PRECISION SUBPROGRAM APPROXIMATES THE*****
C*****INTEGRAL FROM A TO B OF THE FUNCTION FNC(X,INDEX)*****
C*****TO WITHIN A RELATIVE ERROR EPS BY ADAPTIVE SIMPSON****
C*****QUADRATURE AND RETURNS THE APPROXIMATION IN ADPSBC.***
C*****THE FUNCTION FNC(X,INDEX) IS A DOUBLE PRECISION ******
C*****EXTERNAL FUNCTION SUBPROGRAM WHICH EVALUATES THE *****
C*****FUNCTION AT POINT X. INDEX IS A POINTER TO ONE OF ****
C*****SEVERAL INTEGRANDS CONTAINED IN THE CODE OF     ******
C*****FNC(X,INDEX). NP IS RETURNED TO THE CALLING PRO- *****
C*****GRAM AS ONE LESS THAN THE NUMBER OF INTEGRAND EVAL- **
C*****UATIONS USED TO OBTAIN THE RESULT ADPSBC.        *****
C*****************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION EPSP(30),F2(30),F3(30),FMP(30),XM(30),FBP(30),
     *DX(30),X2(30),X3(30),EST2(30),ITRN(30),PVAL(30,2)
      LOGICAL TEST
      CORR = 0D0
      NP = 0
      EPS = 15D0*EPS
      LVL = 0
      ABSA = 1D0
      EST = 1D0
      DA = B - A
      FA = FNC(A,INDEX)
      FM = 4D0*FNC((A + B)*0.5D0,INDEX)
      FB = FNC(B,INDEX)
      NP = 2
      ASSIGN 20001 TO KROC01
      GO TO 30001
20001 CONTINUE
20002 CONTINUE
      IF(.NOT.(TEST)) GO TO 20003
      LVL = LVL - 1
      ICOL = ITRN(LVL)
      PVAL(LVL,ICOL) = SUM
      ASSIGN 20005 TO KROC02
      GO TO 30002
20005 CONTINUE
      GO TO 20004
20003 CONTINUE
      ITRN(LVL) = 1
      DA = DX(LVL)
      FM = F2(LVL)
      FB = FMP(LVL)
      EPS = EPSP(LVL)*0.5D0
      EST = EST1   ! SAVE 3 POINT APPROX. ON (A, A+DA)
      ASSIGN 20006 TO KROC01
      GO TO 30001
20006 CONTINUE
20004 CONTINUE
      IF(.NOT.(LVL.EQ.1)) GO TO 20002
      ADPSBC = SUM - CORR/15D0
      RETURN
C     PROCEDURE RECUR
30001 CONTINUE
      LVL = LVL + 1
      DX(LVL) = DA*0.5D0
      SX = DX(LVL)/6D0
      XM(LVL) = A + DX(LVL)
      X2(LVL) = A+DX(LVL)*0.5D0
      F2(LVL) = 4D0*FNC(X2(LVL),INDEX)
      X3(LVL) = X2(LVL) + DX(LVL)
      F3(LVL) = 4D0*FNC(X3(LVL),INDEX)
      EPSP(LVL) = EPS
      FMP(LVL) = FM*0.25D0
      EST1 = (FA + F2(LVL) + FMP(LVL))*SX
      FBP(LVL) = FB
      EST2(LVL) = (FMP(LVL) + F3(LVL) + FB)*SX
      SUM = EST1 + EST2(LVL)        ! STORE 5 POINT APPROX. IN SUM
      ABSA = ABSA - ABS(EST) + ABS(EST1) + ABS(EST2(LVL))
      CI = EST - SUM
      TEST = ABS(CI).LE.EPSP(LVL)*ABSA        ! SET COMPARISON TEST
      TEST = TEST.AND.(EST.NE.1D0)
      TEST = TEST.OR.LVL.GE.30
      IF(TEST)CORR = CORR + CI
      NP = NP +2
      GO TO KROC01
C     PROCEDURE CAS
30002 CONTINUE
      GO TO(20007,20008), ICOL
20007 CONTINUE
      ITRN(LVL) = 2
      DA = DX(LVL)
      FA = FMP(LVL)
      FM = F3(LVL)
      FB = FBP(LVL)
      EPS = EPSP(LVL)*0.5D0
      A = XM(LVL)
      EST = EST2(LVL)
      ASSIGN 20010 TO KROC01
      GO TO 30001
20010 CONTINUE
      GO TO  20009
20008 CONTINUE
      SUM = PVAL(LVL,1) + PVAL(LVL,2)
20009 CONTINUE
      GO TO KROC02
      END
C
C
C
      DOUBLE PRECISION FUNCTION FNC(Y,INDEX)
C THIS SUBPROGRAM COMPUTES THE INTEGRAND
C     U*EXP(-Y)/SQRT(Z**2+B**2)     IF RANGE.GT.0.
C     U*EXP(-Y)                     IF RANGE.LT.0.
C        INPUTS    Y
C                  INDEX=1 OR 2
C                  U0=TWOALF*COSNU
C                  V0=KR*(1-COSNU)
C                  RANGE
C                  BSQ=B**2               (COMPLEX)
C        OUTPUTS   RT=SQRT(Z**2+B**2)     (COMPLEX)
C                  FNC(Y,1)=REAL PART
C                  FNC(Y,2)=IMAGINARY PART
      COMPLEX*16 RT,Z,U,Y3,BSQ
      DOUBLE PRECISION Y,U0,V0
      COMMON/BLK3/U0
      COMMON/TAN/RANGE
      COMMON/ORANGE/RT
      COMMON/FUCIA/BSQ,V0
      IF(RANGE.GT.0.0) GO TO 401
      Z=DCMPLX(Y+U0,-V0)
      RT=CDSQRT(Z**2+BSQ)
      CALL UEVAL(Y,Z,U)
      Y3=U*DCMPLX(DEXP(-Y),0D0)
      IF(INDEX.EQ.1) FNC=DREAL(Y3)
      IF(INDEX.EQ.2) FNC=DIMAG(Y3)
      RETURN
  401 Z=DCMPLX(Y-U0,V0)
      RT=CDSQRT(Z**2+BSQ)
      CALL UEVAL(Y,Z,U)
      Y3=U*DCMPLX(DEXP(-Y),0D0)/RT
      IF(INDEX.EQ.1) FNC=DREAL(Y3)
      IF(INDEX.EQ.2) FNC=DIMAG(Y3)
      RETURN
      END
C
C
C
      SUBROUTINE UEVAL(Y,Z,U)
C THIS SUBPROGRAM COMPUTES THE SATURATION-TAPER U(R'/R0).
C        INPUTS    Y   (USED ONLY IF RANGE.LT.ZERO)
C                  V0  (USED ONLY IF RANGE.LT.ZERO)
C                  Z                      (COMPLEX)
C                  CONST1=COSNU*RANGE
C                  CONST3=3*(CHI/PI)**2
C                  RT=SQRT(Z**2+B**2)     (COMPLEX)
C                  TWOALF=2*ALPHA*R
C                  RANGE
C                  ASPECT
C                  AKOTAL=ALPHA/(2*K)
C                  ISHAPE=0,1,2,3, OR 4
C                  BSQ=B**2               (COMPLEX)
C        OUTPUT    U                      (COMPLEX)
      COMPLEX*16 RT,Z,U,BB,RPRIME,XI,BSQ,DELTA
      DOUBLE PRECISION Y,V0,TWOALF,CONST3,CONST1,AKOTAL
      DOUBLE PRECISION ZTEST,XITEST
      COMMON/BLK1/TWOALF
      COMMON/TAN/RANGE
      COMMON/BLUE/ASPECT,ISHAPE
      COMMON/YELLOW/CONST3
      COMMON/BROWN/CONST1,AKOTAL
      COMMON/ORANGE/RT
      COMMON/FUCIA/BSQ,V0
C IF CHIDB.LE.-35, SET U=(1.0,0.0)
      IF(CONST3.LT.1.0D-04) GO TO 101
      ZTEST=CDABS(Z-RT)/CDABS(Z)
      RPRIME=DCMPLX(1D0,AKOTAL)*Z-CMPLX(0D0,AKOTAL)*RT
      IF(ZTEST.LE.1D-2) RPRIME=Z*((1D0,0D0)-DCMPLX(0D0,.5D0*AKOTAL)
     **((BSQ/Z**2)-(.25D0,0D0)*((BSQ/Z**2)**2)+(.125D0,0D0)*
     *((BSQ/Z**2)**3)))
      RPRIME=RPRIME*DCMPLX((DBLE(RANGE)/TWOALF),0D0)/DCMPLX(1D0,
     *2D0*AKOTAL)
      IF(RANGE.LT.0.0) RPRIME=DCMPLX(DBLE(RANGE)*Y,0D0)/DCMPLX
     *(TWOALF,V0)
      IF(RANGE.GT.0.0) RPRIME=RPRIME+DCMPLX(CONST1,0D0)
      IF(ISHAPE.NE.2) BB=RPRIME+CDSQRT((1D0,0D0)+RPRIME**2)
      IF(ISHAPE.EQ.2) BB=((2D0,0D0)*RPRIME+DCMPLX(DBLE(ASPECT-1.)
     *,0D0)+(2D0,0D0)*CDSQRT((1D0,0D0)+DCMPLX(DBLE(ASPECT-1.),0D0)*
     *RPRIME+RPRIME**2))/DCMPLX(DBLE(1.+ASPECT),0D0)
      XI=DCMPLX(CONST3,0D0)*(CDLOG(BB)**2)
      IF(CDABS(RPRIME).LT.1D-1.AND.ISHAPE.NE.2) XI=DCMPLX
     *(CONST3,0D0)*((.075D0,0D0)*(RPRIME**5)-DCMPLX(1D0/6D0,0D0)*
     *(RPRIME**3)+RPRIME)**2
      IF(ISHAPE.NE.2) GO TO 103
      DELTA=DCMPLX(0.5D0*DBLE(ASPECT-1.0),0D0)
      IF(CDABS(RPRIME).LT.1D-1.AND.CDABS(DELTA).LT.2D-2) XI=
     *DCMPLX(CONST3,0D0)*(DCMPLX(DLOG(2D0/DBLE(1.+ASPECT)),0D0)+
     *DELTA+RPRIME-(.5D0,0D0)*DELTA**2+(DELTA+RPRIME)*
     *(DELTA**2-(2D0,0D0)*DELTA*RPRIME-RPRIME**2)/(3D0,0D0)
     *-(.25D0,0D0)*DELTA**4+(.2D0,0D0)*(DELTA+RPRIME)*
     *(DELTA**4-RPRIME*DELTA**3+(DELTA*RPRIME)**2+(1.5D0,0D0)
     **DELTA*RPRIME**3+(.375D0,0D0)*RPRIME**4))**2
  103 IF(CDABS(XI).LT.2D-2) GO TO 102
      XITEST=CDABS((1D0,0D0)+(2D0,0D0)*XI)
      IF(XITEST.LT.1D-18) U=((1D0,0D0)+XI)*(1D9,0D0)
      IF(XITEST.GE.1D-18.AND.XITEST.LE.1D-2) U=((1D0,0D0)+XI)/CDSQR
     *T(DCMPLX(1D-2/XITEST,0D0)*((1D0,0D0)+(2D0,0D0)*XI))-(1D0,0D0)
      IF(XITEST.GT.0.01D0) U=((1D0,0D0)+XI)/CDSQRT((1D0,0D0)
     *+(2D0,0D0)*XI)-(1D0,0D0)
      U=U*(2D0,0D0)/(XI**2)
      RETURN
  102 U=(1D0,0D0)-(2D0,0D0)*XI+(3.75D0,0D0)*(XI**2)-(7D0,0D0)*(XI**3)
      RETURN
  101 U=(1D0,0D0)
      RETURN
      END
C
C
C
      SUBROUTINE QGM48
C THIS SUBPROGRAM COMPUTES WEIGHTING FACTORS FOR THE GAUSSIAN
C QUADRATURE.
      COMMON/WHT/C(24),W(24)
      C(1)=.99877101
      C(2)=.99353017
      C(3)=.98412458
      C(4)=.97059159
      C(5)=.95298770
      C(6)=.93138669
      C(7)=.90587914
      C(8)=.87657202
      C(9)=.84358826
      C(10)=.80706620
      C(11)=.76715903
      C(12)=.72403413
      C(13)=.67787238
      C(14)=.62886740
      C(15)=.57722473
      C(16)=.52316097
      C(17)=.46690290
      C(18)=.40868648
      C(19)=.34875589
      C(20)=.28736249
      C(21)=.22476379
      C(22)=.16122236
      C(23)=.97004699E-1
      C(24)=.32380171E-1
      W(1)=.31533461E-2
      W(2)=.73275539E-2
      W(3)=.11477235E-1
      W(4)=.15579316E-1
      W(5)=.19616160E-1
      W(6)=.23570761E-1
      W(7)=.27426510E-1
      W(8)=.31167228E-1
      W(9)=.34777223E-1
      W(10)=.38241351E-1
      W(11)=.41545083E-1
      W(12)=.44674561E-1
      W(13)=.47616658E-1
      W(14)=.50359036E-1
      W(15)=.52890189E-1
      W(16)=.55199504E-1
      W(17)=.57277292E-1
      W(18)=.59114840E-1
      W(19)=.60704439E-1
      W(20)=.62039423E-1
      W(21)=.63114192E-1
      W(22)=.63924239E-1
      W(23)=.64466164E-1
      W(24)=.64737697E-1
      RETURN
      END
C
C
C
      SUBROUTINE FCT(ARG,ARG1,ARG2)
C THIS SUBPROGRAM COMPUTES THE THETAPRIME INTEGRAND =
C     SIN(THETAPRIME)*D0**2*(INTEGRAL OVER PHIPRIME).
C        INPUTS    STH=SIN(THETA)
C                  CTH=COS(THETA)
C                  ARG=THETAPRIME
C                  PHIR=PHI(RAD)
C                  ASPECT
C                  ISHAPE=0,1,2,3, OR 4
C                  R0K0
C                  C(24)
C                  W(24)
C                  BPSQ(200)
C                  ANGLE(200)
C        OUTPUTS   ARG1=REAL PART
C                  ARG2=IMAGINARY PART
C                  ICOUNT=NO.OF PHIPRIME POINTS / 48
      REAL MMBSJ1
      COMMON/BLUE/ASPECT,ISHAPE
      COMMON/WHT/C(24),W(24)
      COMMON/GREEN/ICOUNT
      COMMON/GREY/BWEFR,BW0R,STH,CTH,PI,ANGLE(200),BPSQ(200)
      COMMON/PINK/R0K0,PHIR
      S=SIN(ARG)
      CO=COS(ARG)
      COCTH=CO*CTH
      SSTH=S*STH
      N=1+INT(PI*S/(180.*BW0R))
      NNNN=N
      ARG1=0.0
      ARG2=0.0
      ARG11=0.0
      ARG12=0.0
      ICOUNT=0
      IF(ISHAPE.EQ.0.OR.ISHAPE.GE.3) GO TO 604
      IF(ISHAPE.EQ.1) GO TO 605
      ARG3=SQRT(0.5*PI*R0K0/ASPECT)*S
      IF(PHIR.EQ.0.0) GO TO 606
      ARG3=ARG3*ASPECT
      GO TO 606
  604 IF(ISHAPE.EQ.0) ARG3=SQRT(2.0*R0K0)*S
      IF(ISHAPE.EQ.3) ARG3=0.5*PI*R0K0*(1.0-CO)
      IF(ISHAPE.EQ.3.AND.S.LE.0.01) ARG3=0.25*PI*R0K0*(ARG**2)
      N=1
      GO TO 606
  605 ARG3=SQRT(PI*R0K0*0.5)*S
  606 ENN=FLOAT(N)
      IF(N.EQ.1) GO TO 622
      IF(BWEFR.GE.BW0R/S) GO TO 623
  622 IF(BWEFR.GE.1.0) GO TO 623
      IF(ABS(S-STH).LT.BWEFR) GO TO 618
  623 B=PI/ENN
      A=PI-0.5*B
      L=1
      GO TO 625
  618 B=(PI-BWEFR)/ENN
      A=PI-0.5*B
      L=2
  625 DO 626 J=1,NNNN
  619 DO 603 I=1,24
      DO 617 K=1,2
      DKAY=FLOAT(K)
      PHIPRI=A+B*C(I)*(1.5-DKAY)
      COSNU=COCTH+SSTH*COS(PHIPRI)
      CALL FCTPHI(COSNU,VAL1,VAL2)
      IF(ISHAPE.EQ.0.OR.ISHAPE.GE.3) GO TO 607
      CPRI=COS(PHIPRI)
      SPRI=SIN(PHIPRI)
      ARG4=ARG3*CPRI
      ARG5=ARG3*SPRI
      IF(ISHAPE.EQ.1) GO TO 612
      IF(PHIR.EQ.0.0) GO TO 616
      ARG5=ARG5/ASPECT
      GO TO 612
  616 ARG5=ARG5*ASPECT
  612 IF(ARG4.EQ.0.0) GO TO 608
      D0=SIN(ARG4)/ARG4
      GO TO 609
  608 D0=1.0
  609 IF(ARG5.EQ.0.0) GO TO 610
      D0=D0*SIN(ARG5)/ARG5
  610 FAC=(D0**2)*W(I)
      GO TO 614
  607 FAC=W(I)
  614 ARG1=ARG1+FAC*VAL1
  617 ARG2=ARG2+FAC*VAL2
  603 CONTINUE
      ICOUNT=ICOUNT+1
      IF(L.EQ.3) GO TO 621
      A=A-B
  626 CONTINUE
      FAC=B*S
      IF(L.EQ.1) GO TO 628
      L=3
      ARG11=ARG1*FAC
      ARG12=ARG2*FAC
      ARG1=0.0
      ARG2=0.0
      B=BWEFR
      A=0.5*B
      NNNN=1
      GO TO 625
  621 FAC=B*S
      ARG1=ARG1*FAC+ARG11
      ARG2=ARG2*FAC+ARG12
      GO TO 629
  628 ARG1=ARG1*FAC
      ARG2=ARG2*FAC
  629 IF(ISHAPE.EQ.1.OR.ISHAPE.EQ.2) GO TO 613
      IF(ISHAPE.EQ.0.OR.ISHAPE.EQ.3) GO TO 630
      M=1
  632 IF(ARG.LE.ANGLE(M)) GO TO 631
      M=M+1
      GO TO 632
  631 M2=M
      M1=M-1
      IF(M1.EQ.0) GO TO 633
      D0=(BPSQ(M2)-BPSQ(M1))*(ARG-ANGLE(M1))/(ANGLE(M2)-ANGLE(M1))
      D0=D0+BPSQ(M1)
      GO TO 602
  633 D0=BPSQ(1)
      GO TO 602
  630 IF(ARG3.EQ.0.0) GO TO 601
      IF(ISHAPE.EQ.0) D0=2.0*MMBSJ1(ARG3)/ARG3
      IF(ISHAPE.EQ.3) D0=SIN(ARG3)/ARG3
      D0=D0**2
      GO TO 602
  601 D0=1.0
  602 CONTINUE
      ARG1=ARG1*D0
      ARG2=ARG2*D0
  613 RETURN
      END
C
C
C
      SUBROUTINE FCTPHI(COSNU,VAL1,VAL2)
C THIS SUBPROGRAM DOES THE PHIPRIME INTEGRAND, EXP(JKR)*I(COSNU).
C        INPUTS    COSNU
C                  VALUE1(225)
C                  VALUE2(225)
C        OUTPUTS   VAL1=REAL PART
C                  VAL2=IMAGINARY PART
      COMMON/RED/VALUE1(240),VALUE2(240)
      IF(COSNU.GT.1.0) THEN
	VAL1=VALUE1(1)
	VAL2=VALUE2(1)
	RETURN
      END IF
      IF(COSNU.LT.-1.0) THEN
	VAL1=VALUE1(225)
	VAL2=VALUE2(225)
	RETURN
      END IF
      GNU=ACOS(COSNU)
      C=1.0E04*GNU
      I=INT(C)
      IF(I.GT.0) GO TO 500
      VAL1=VALUE1(1)
      VAL2=VALUE2(1)
      RETURN
  500 IF(I.LT.10) GO TO 502
      IF(I.GE.100) GO TO 501
      C=1000.*GNU+9.
      GO TO 506
  501 IF(I.GE.10000) GO TO 504
      C=100.*GNU+18.
      GO TO 506
  504 IF(I.GE.31400) GO TO 507
      C=50.*GNU+68.
      GO TO 506
  507 VAL1=VALUE1(225)
      VAL2=VALUE2(225)
      RETURN
  506 I=INT(C)
  502 CII=C-FLOAT(I)
      VAL1=VALUE1(I)
      VAL1=VAL1+(VALUE1(I+1)-VAL1)*(CII)
      VAL2=VALUE2(I)
      VAL2=VAL2+(VALUE2(I+1)-VAL2)*(CII)
      RETURN
      END
C
C      REMOVED FORM THE PC VERSION
C
      SUBROUTINE MMSTOR(THETA,BDG,BDGAP,NPOINT)
C     PETER R MINER   APR 1977
      COMMON/PURPLE/XARRAY(200),YARRAY(200),ZARRAY(200)
      NPOINT=NPOINT+1
      IF(NPOINT.GT.200) GO TO 750
      IF(NPOINT.EQ.1) THEN
	XARRAY(69)=THETA
	YARRAY(69)=BDG
	ZARRAY(69)=BDGAP
      ELSE
	XARRAY(70-NPOINT)=-THETA
	XARRAY(68+NPOINT)=THETA
	YARRAY(70-NPOINT)=BDG
	YARRAY(68+NPOINT)=BDG
	ZARRAY(70-NPOINT)=BDGAP
	ZARRAY(68+NPOINT)=BDGAP
      END IF
      RETURN
  750 PRINT 2000 
 2000 FORMAT(' PLOT STORAGE OVERFLOW')  
      NPOINT=200
      RETURN
      END
C  
C      REMOVED FROM THE PC VERSION     F.R.S
C
C      SUBROUTINE MMPLOT
C      COMMON/TAN/RANGE
C      COMMON/BLUE/ASPECT,ISHAPE
C      COMMON/PURPLE/XARRAY(200),YARRAY(200),ZARRAY(200)
C      COMMON/ODRAB1/FZERO,SLZERO,BW0,BW1,BW2,RZERO,ALFAR0
C      COMMON/ODRAB2/FDIFF,SL,BEAMW,R
C      COMMON/PINK/R0K0,PHIR
C SET UP POLAR GRID
C      CALL BFIL(1)
C      CALL BJOB
C      CALL BFRM(1)
C      CALL SWRKS(500.,250.,10000.,8000.,0.)
C      CALL DRECG(0,0)
C      CALL SWRKS(0.,250.,10000.,8000.,0.)
C      CALL DPOLG(5,36,0.,-60.,4000.,360.)
C      CALL SWRKS(500.,250.,10000.,8000.,0.)
C ATTACH LABELS
C      CALL SLABP(2,10.,150.,0.,-90.)
C      CALL SSPC(100.,100.)
C      CALL LSTRG('MOFFETT',100.,1000.)
C      CALL SSPC(150.,150.)
C      CALL LSTRG('FZERO = ',9700.,7900.)
C      CALL LNUMR(FZERO,1,9700.,6700.)
C      CALL LSTRG('kHz',9700.,5950.)
C      CALL LSTRG('SLZERO = ',9400.,7900.)
C      CALL LNUMR(SLZERO,1,9400.,6550.)
C      CALL LSTRG('dB//uPa-m',9400.,5800.)
C      CALL LSTRG('BWZERO = ',9100.,7900.)
C      IF(ISHAPE.NE.2) THEN
C        CALL LNUMR(BW0,1,9100.,6550.)
C      ELSE
C        IF(PHIR.EQ.0.0) THEN
C          CALL LNUMR(BW1,1,9100.,6550.)
C        ELSE
C          CALL LNUMR(BW2,1,9100.,6550.)
C        END IF
C      END IF
C      CALL LSTRG('deg',9100.,5950.)
C      CALL LSTRG('RZERO = ',8800.,7900.)
C      CALL LNUMR(RZERO,3,8800.,6700.)
C      CALL LSTRG('m',8800.,5650.)
C      CALL LSTRG('ALFAR0 = ',8500.,7900.)
C      CALL LNUMR(ALFAR0,5,8500.,6550.)
C      CALL LSTRG('dB',8500.,5350.)
C      CALL LSTRG('10 dB/division',700.,2250.)
C      CALL LSTRG('10 deg/division',400.,2250.)
C      IF(ISHAPE.EQ.2) THEN
C        CALL LSTRG('RECTANGLE',700.,7900.)
C        CALL LSTRG('ASPECT = ',400.,7900.)
C        CALL LNUMR(ASPECT,2,400.,6550.)
C        IF(PHIR.EQ.0.0) THEN
C          CALL LSTRG('PHI = 0 deg',100.,7900.)
C        ELSE
C          CALL LSTRG('PHI = 90 deg',100.,7900.)
C        END IF
C      ELSE
C        IF(ISHAPE.EQ.0) CALL LSTRG('CIRCLE',100.,7900.)
C        IF(ISHAPE.EQ.1) CALL LSTRG('SQUARE',100.,7900.)
C        IF(ISHAPE.EQ.3) CALL LSTRG('ENDFIRE',100.,7900.)
C        IF(ISHAPE.EQ.4) CALL LSTRG('AXISYMMETRIC BEAM',100.,7900.)
C      END IF
C      CALL LSTRG('F = ',9700.,3000.)
C      CALL LNUMR(FDIFF,3,9700.,2400.)
C      CALL LSTRG('kHz',9700.,1350.)
C      CALL LSTRG('SL = ',9400.,3000.)
C      CALL LNUMR(SL,1,9400.,2250.)
C      CALL LSTRG('dB//uPa-m',9400.,1500.)
C      CALL LSTRG('BW = ',9100.,3000.)
C      CALL LNUMR(BEAMW,1,9100.,2250.)
C      CALL LSTRG('deg',9100.,1650.)
C      IF(R.GE.0.) THEN
C        CALL LSTRG('R = ',8800.,3000.)
C        CALL LNUMR(R,1,8800.,2400.)
C        CALL LSTRG('m',8800.,1350.)
C      ELSE
C        CALL LSTRG('INFINITE RANGE',8800.,3000.)
C      END IF
C PLOT BEAM PATTERN
C      CALL SWRKS(0.,250.,10000.,8000.,0.)
C      CALL SDATP(-50.,-60.,50.,120.)
C      CALL DPOLP(137,ZARRAY,XARRAY,0,0,0)
C      CALL EFRM
C      CALL EJOB
C      CALL EFIL
C      RETURN
C      END
C       
C      -----------------------------------------------------------------
C      FUNCTION  MMBSJ1  computes the first order Bessel function J1.
C
C      -------------------------
C      Specification statements.
C      -------------------------
       REAL FUNCTION MMBSJ1(X)
C
       IMPLICIT REAL (A-H,O-Z)
C
C
C      ----------------------
C      Process each argument.
C      ---------------------
C
C
C           ----------------------------------------
C           Determine the magnitude of the argument.
C           ----------------------------------------
	    Y = ABS( X )
	    IF( Y .GT. 3.0 )  GO TO 1000
C
C
C           ----------------------
C           The argument is small.
C           ----------------------
	    S  = 0.1111111111 * Y**2
	    MMBSJ1 = X*(.5+S*(-.56249985+S*(.21093573+S*(-.03954289+S*
     1             (.00443319+S*(-.00031761+S*.1109E-4))))))
	    GO TO 8000
C
C
C           ----------------------
C           The argument is large.
C           ----------------------
 1000       S = 3.0 / Y
	    F = .79788456+S*(.156E-5+S*(.01659667+S*(.00017105+S*
     1        (-.00249511+S*(.00113653-S*.00020033)))))
C
	    T = Y-2.35619449+S*(.12499612+S*(.565E-4+S*(-.00637879+S*
     1        (.00074348+S*(.00079824-S*.00029166)))))
C
	    IF( X .LT. 0.0 )  F = -F
	    B = .5773502692 * COS(T)
	    MMBSJ1 = B * F * SQRT(S)
C
C
C      -----------------------
C      Increment the argument.
C      -----------------------
 8000  RETURN
C
C
C      ------
C      ------
       END
